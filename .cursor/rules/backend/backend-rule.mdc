---
alwaysApply: true
---
# Prompt para Agente de Desenvolvimento Supabase

## Contexto
Você é um especialista em desenvolvimento backend com Supabase, especializado na criação de Edge Functions como camada de API, funções RPC (Remote Procedure Call) PostgreSQL para lógica de dados, design de tabelas e políticas RLS (Row Level Security).

## Arquitetura Obrigatória

### Princípio Fundamental
**SEMPRE siga esta arquitetura em camadas:**

```
Cliente (Frontend)
    ↓
Edge Function (Camada de API)
    ↓
Função RPC (Lógica de Negócio no PostgreSQL)
    ↓
Tabelas com RLS (Camada de Dados)
```

### Regras de Ouro
1. **Edge Functions são SEMPRE a camada de API** - Toda comunicação com o cliente passa por Edge Functions
2. **Funções RPC são SEMPRE chamadas dentro de Edge Functions** - Nunca exponha RPC diretamente ao cliente
3. **Edge Functions orquestram** - Validação, autenticação, transformação de dados
4. **Funções RPC executam** - Lógica de negócio, transações complexas, queries otimizadas
5. **RLS protege** - Última camada de segurança a nível de dados

### Vantagens desta Arquitetura
- ✅ **Segurança**: Edge Functions como gateway controlado
- ✅ **Validação**: Dados validados antes de chegar ao banco
- ✅ **Transformação**: Adapte respostas para o cliente
- ✅ **Logging**: Centralize logs e monitoramento
- ✅ **Rate Limiting**: Controle de taxa na camada de API
- ✅ **Versionamento**: Múltiplas versões da API sem alterar RPC
- ✅ **Testes**: Edge Functions testáveis independentemente

---

## Edge Functions - Camada de API

### Responsabilidades
1. **Autenticação e Autorização** - Validar JWT e permissões
2. **Validação de Input** - Sanitizar e validar dados recebidos
3. **Orquestração** - Chamar uma ou múltiplas funções RPC
4. **Transformação de Dados** - Adaptar resposta do RPC para o cliente
5. **Tratamento de Erros** - Retornar erros formatados e seguros
6. **Rate Limiting** - Controlar taxa de requisições
7. **Logging e Métricas** - Registrar operações e performance

### Template Padrão de Edge Function

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Configuração de CORS
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Interfaces para type safety
interface RequestBody {
  // Defina a estrutura esperada
}

interface RPCResponse {
  // Defina a estrutura da resposta RPC
}

// Função helper para validação
function validateInput(data: any): { valid: boolean; error?: string } {
  // Implemente validações específicas
  if (!data) {
    return { valid: false, error: 'Missing required data' }
  }
  return { valid: true }
}

// Função helper para logging
function logRequest(method: string, userId: string | null, duration: number) {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    method,
    userId,
    duration,
  }))
}

serve(async (req) => {
  const startTime = Date.now()
  
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // 1. AUTENTICAÇÃO - Validar token JWT
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      throw new Error('Missing authorization header')
    }

    const token = authHeader.replace('Bearer ', '')
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    
    const supabase = createClient(supabaseUrl, supabaseKey, {
      global: {
        headers: { Authorization: authHeader },
      },
    })

    // Verificar usuário autenticado
    const { data: { user }, error: authError } = await supabase.auth.getUser(token)
    
    if (authError || !user) {
      throw new Error('Unauthorized')
    }

    // 2. VALIDAÇÃO - Extrair e validar dados de entrada
    const body: RequestBody = await req.json()
    const validation = validateInput(body)
    
    if (!validation.valid) {
      return new Response(
        JSON.stringify({ error: validation.error }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )
    }

    // 3. AUTORIZAÇÃO - Verificar permissões específicas (se necessário)
    // Exemplo: verificar role do usuário
    const { data: userData } = await supabase
      .from('users')
      .select('role')
      .eq('id', user.id)
      .single()

    if (userData?.role !== 'admin' && userData?.role !== 'user') {
      throw new Error('Insufficient permissions')
    }

    // 4. CHAMADA RPC - Executar função RPC no PostgreSQL
    const { data: rpcData, error: rpcError } = await supabase
      .rpc('nome_da_funcao_rpc', {
        p_user_id: user.id,
        p_param1: body.param1,
        p_param2: body.param2,
      })

    if (rpcError) {
      console.error('RPC Error:', rpcError)
      throw new Error(`Database operation failed: ${rpcError.message}`)
    }

    // 5. TRANSFORMAÇÃO - Adaptar resposta para o cliente
    const response = {
      success: true,
      data: rpcData,
      meta: {
        timestamp: new Date().toISOString(),
        userId: user.id,
      }
    }

    // 6. LOGGING - Registrar operação
    const duration = Date.now() - startTime
    logRequest(req.method, user.id, duration)

    // 7. RESPOSTA - Retornar dados ao cliente
    return new Response(
      JSON.stringify(response),
      { 
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json',
          'X-Response-Time': `${duration}ms`
        },
        status: 200
      }
    )

  } catch (error) {
    // Tratamento centralizado de erros
    const duration = Date.now() - startTime
    
    console.error('Error:', {
      message: error.message,
      stack: error.stack,
      duration,
    })

    // Mapear erros para status codes apropriados
    let statusCode = 500
    let errorMessage = 'Internal server error'

    if (error.message.includes('Unauthorized') || error.message.includes('authorization')) {
      statusCode = 401
      errorMessage = 'Unauthorized'
    } else if (error.message.includes('permissions')) {
      statusCode = 403
      errorMessage = 'Forbidden'
    } else if (error.message.includes('Missing') || error.message.includes('Invalid')) {
      statusCode = 400
      errorMessage = error.message
    }

    return new Response(
      JSON.stringify({ 
        error: errorMessage,
        timestamp: new Date().toISOString()
      }),
      { 
        status: statusCode,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )
  }
})
```

### Exemplo Completo: Sistema de Posts

#### 1. Edge Function: `create-post`

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface CreatePostBody {
  title: string
  content: string
  tags?: string[]
  is_public?: boolean
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Autenticação
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) throw new Error('Missing authorization')

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
      { global: { headers: { Authorization: authHeader } } }
    )

    const { data: { user } } = await supabase.auth.getUser()
    if (!user) throw new Error('Unauthorized')

    // Validação
    const body: CreatePostBody = await req.json()
    
    if (!body.title || body.title.trim().length < 3) {
      throw new Error('Title must be at least 3 characters')
    }
    
    if (!body.content || body.content.trim().length < 10) {
      throw new Error('Content must be at least 10 characters')
    }

    if (body.title.length > 200) {
      throw new Error('Title cannot exceed 200 characters')
    }

    // Sanitização
    const sanitizedTitle = body.title.trim()
    const sanitizedContent = body.content.trim()
    const tags = body.tags?.filter(tag => tag.trim().length > 0) || []

    // Chamada RPC - A lógica está no banco de dados
    const { data, error } = await supabase.rpc('create_post', {
      p_user_id: user.id,
      p_title: sanitizedTitle,
      p_content: sanitizedContent,
      p_tags: tags,
      p_is_public: body.is_public ?? true
    })

    if (error) {
      console.error('RPC Error:', error)
      throw new Error(error.message)
    }

    // Resposta formatada
    return new Response(
      JSON.stringify({
        success: true,
        data: {
          post: data,
          message: 'Post created successfully'
        }
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: error.message.includes('Unauthorized') ? 401 : 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )
  }
})
```

#### 2. Edge Function: `get-posts`

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const authHeader = req.headers.get('Authorization')
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
      { global: { headers: { Authorization: authHeader || '' } } }
    )

    // Extrair query params
    const url = new URL(req.url)
    const page = parseInt(url.searchParams.get('page') || '1')
    const limit = Math.min(parseInt(url.searchParams.get('limit') || '10'), 100)
    const tag = url.searchParams.get('tag')
    const authorId = url.searchParams.get('author_id')

    // Validação
    if (page < 1) throw new Error('Page must be greater than 0')
    if (limit < 1) throw new Error('Limit must be greater than 0')

    // Obter usuário (opcional para posts públicos)
    let userId = null
    if (authHeader) {
      const { data: { user } } = await supabase.auth.getUser()
      userId = user?.id || null
    }

    // Chamada RPC - Lógica complexa de listagem no banco
    const { data, error } = await supabase.rpc('get_posts_paginated', {
      p_requesting_user_id: userId,
      p_page: page,
      p_limit: limit,
      p_tag_filter: tag,
      p_author_filter: authorId
    })

    if (error) throw new Error(error.message)

    // Transformação e resposta
    return new Response(
      JSON.stringify({
        success: true,
        data: {
          posts: data.posts,
          pagination: {
            page,
            limit,
            total: data.total_count,
            total_pages: Math.ceil(data.total_count / limit)
          }
        }
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
```

---

## Funções RPC - Lógica de Negócio no PostgreSQL

### Responsabilidades
1. **Lógica de Negócio Complexa** - Regras que devem ser executadas no banco
2. **Transações Atômicas** - Garantir consistência de dados
3. **Queries Otimizadas** - Aproveitar índices e capacidades do PostgreSQL
4. **Cálculos e Agregações** - Processar dados próximo ao storage
5. **Validações de Integridade** - Validações que dependem de dados existentes

### Template Padrão de Função RPC

```sql
CREATE OR REPLACE FUNCTION function_name(
  p_user_id UUID,
  p_param1 TYPE,
  p_param2 TYPE
)
RETURNS TABLE (
  -- Defina os campos de retorno
  field1 TYPE,
  field2 TYPE
) 
LANGUAGE plpgsql
SECURITY INVOKER  -- Executa com permissões do usuário chamador
VOLATILE  -- Usa VOLATILE para operações de escrita, STABLE para leituras
SET search_path = public  -- Segurança: define schema explicitamente
AS $$
DECLARE
  v_variable TYPE;  -- Variáveis locais
BEGIN
  -- 1. VALIDAÇÕES
  -- Valide os parâmetros de entrada
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'user_id cannot be null';
  END IF;

  IF p_param1 IS NULL OR p_param1 = '' THEN
    RAISE EXCEPTION 'param1 is required';
  END IF;

  -- 2. VERIFICAÇÕES DE PERMISSÃO
  -- Verifique se o usuário tem permissão para esta operação
  -- (RLS já oferece proteção, mas validações extras podem ser necessárias)
  IF NOT EXISTS (
    SELECT 1 FROM users 
    WHERE id = p_user_id 
    AND deleted_at IS NULL
  ) THEN
    RAISE EXCEPTION 'User not found or inactive';
  END IF;

  -- 3. LÓGICA DE NEGÓCIO
  -- Execute a operação principal
  -- Exemplo: Inserir dados
  INSERT INTO table_name (field1, field2, user_id)
  VALUES (p_param1, p_param2, p_user_id)
  RETURNING id INTO v_variable;

  -- 4. OPERAÇÕES RELACIONADAS
  -- Execute operações em cascata se necessário
  -- Exemplo: Atualizar contadores, criar registros relacionados, etc.

  -- 5. RETORNO
  -- Retorne os dados necessários
  RETURN QUERY
  SELECT 
    t.field1,
    t.field2
  FROM table_name t
  WHERE t.id = v_variable;

EXCEPTION
  WHEN OTHERS THEN
    -- Log de erro (aparece nos logs do Supabase)
    RAISE LOG 'Error in function_name: %', SQLERRM;
    -- Re-lançar exceção para a Edge Function capturar
    RAISE;
END;
$$;

-- Comentário para documentação
COMMENT ON FUNCTION function_name IS 
'Descrição detalhada do que a função faz, parâmetros e retorno';

-- Permissões
GRANT EXECUTE ON FUNCTION function_name TO authenticated;
REVOKE EXECUTE ON FUNCTION function_name FROM anon;
```

### Exemplo Completo: Funções RPC para Posts

#### 1. Função RPC: `create_post`

```sql
CREATE OR REPLACE FUNCTION create_post(
  p_user_id UUID,
  p_title TEXT,
  p_content TEXT,
  p_tags TEXT[] DEFAULT '{}',
  p_is_public BOOLEAN DEFAULT TRUE
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  content TEXT,
  author_id UUID,
  author_name TEXT,
  tags TEXT[],
  is_public BOOLEAN,
  created_at TIMESTAMPTZ,
  view_count INTEGER
)
LANGUAGE plpgsql
SECURITY INVOKER
VOLATILE
SET search_path = public
AS $$
DECLARE
  v_post_id UUID;
  v_user_can_post BOOLEAN;
  v_user_name TEXT;
BEGIN
  -- 1. VALIDAÇÕES
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'user_id is required';
  END IF;

  IF p_title IS NULL OR LENGTH(TRIM(p_title)) < 3 THEN
    RAISE EXCEPTION 'Title must be at least 3 characters';
  END IF;

  IF p_content IS NULL OR LENGTH(TRIM(p_content)) < 10 THEN
    RAISE EXCEPTION 'Content must be at least 10 characters';
  END IF;

  IF LENGTH(p_title) > 200 THEN
    RAISE EXCEPTION 'Title cannot exceed 200 characters';
  END IF;

  -- 2. VERIFICAÇÕES DE PERMISSÃO
  -- Verificar se usuário existe e está ativo
  SELECT 
    (role IN ('user', 'admin', 'moderator') AND deleted_at IS NULL),
    full_name
  INTO v_user_can_post, v_user_name
  FROM users
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'User not found';
  END IF;

  IF NOT v_user_can_post THEN
    RAISE EXCEPTION 'User does not have permission to create posts';
  END IF;

  -- Verificar rate limiting (máximo 10 posts por hora)
  IF (
    SELECT COUNT(*) 
    FROM posts 
    WHERE author_id = p_user_id 
    AND created_at > NOW() - INTERVAL '1 hour'
  ) >= 10 THEN
    RAISE EXCEPTION 'Rate limit exceeded. Maximum 10 posts per hour.';
  END IF;

  -- 3. CRIAR POST
  INSERT INTO posts (
    author_id,
    title,
    content,
    is_public,
    view_count
  ) VALUES (
    p_user_id,
    TRIM(p_title),
    TRIM(p_content),
    p_is_public,
    0
  )
  RETURNING posts.id INTO v_post_id;

  -- 4. ADICIONAR TAGS (se fornecidas)
  IF array_length(p_tags, 1) > 0 THEN
    INSERT INTO post_tags (post_id, tag)
    SELECT v_post_id, LOWER(TRIM(unnest))
    FROM unnest(p_tags)
    WHERE LENGTH(TRIM(unnest)) > 0
    ON CONFLICT (post_id, tag) DO NOTHING;
  END IF;

  -- 5. ATUALIZAR ESTATÍSTICAS DO USUÁRIO
  UPDATE user_stats
  SET 
    total_posts = total_posts + 1,
    updated_at = NOW()
  WHERE user_id = p_user_id;

  -- Se não existe registro de stats, criar
  IF NOT FOUND THEN
    INSERT INTO user_stats (user_id, total_posts)
    VALUES (p_user_id, 1)
    ON CONFLICT (user_id) DO NOTHING;
  END IF;

  -- 6. RETORNAR DADOS DO POST CRIADO
  RETURN QUERY
  SELECT 
    p.id,
    p.title,
    p.content,
    p.author_id,
    v_user_name AS author_name,
    COALESCE(
      ARRAY_AGG(pt.tag) FILTER (WHERE pt.tag IS NOT NULL),
      '{}'::TEXT[]
    ) AS tags,
    p.is_public,
    p.created_at,
    p.view_count
  FROM posts p
  LEFT JOIN post_tags pt ON pt.post_id = p.id
  WHERE p.id = v_post_id
  GROUP BY p.id, p.title, p.content, p.author_id, p.is_public, p.created_at, p.view_count;

EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error in create_post for user %: %', p_user_id, SQLERRM;
    RAISE EXCEPTION '%', SQLERRM;
END;
$$;

COMMENT ON FUNCTION create_post IS 
'Cria um novo post com validações, rate limiting e atualização de estatísticas';

GRANT EXECUTE ON FUNCTION create_post TO authenticated;
```

#### 2. Função RPC: `get_posts_paginated`

```sql
CREATE OR REPLACE FUNCTION get_posts_paginated(
  p_requesting_user_id UUID DEFAULT NULL,
  p_page INTEGER DEFAULT 1,
  p_limit INTEGER DEFAULT 10,
  p_tag_filter TEXT DEFAULT NULL,
  p_author_filter UUID DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY INVOKER
STABLE
SET search_path = public
AS $$
DECLARE
  v_offset INTEGER;
  v_total_count INTEGER;
  v_posts JSON;
BEGIN
  -- 1. VALIDAÇÕES
  IF p_page < 1 THEN
    RAISE EXCEPTION 'Page must be greater than 0';
  END IF;

  IF p_limit < 1 OR p_limit > 100 THEN
    RAISE EXCEPTION 'Limit must be between 1 and 100';
  END IF;

  -- Calcular offset
  v_offset := (p_page - 1) * p_limit;

  -- 2. CONSTRUIR QUERY BASE
  -- Contar total de posts que atendem aos filtros
  SELECT COUNT(DISTINCT p.id)
  INTO v_total_count
  FROM posts p
  LEFT JOIN post_tags pt ON pt.post_id = p.id
  WHERE 
    p.deleted_at IS NULL
    AND (
      -- Posts públicos OU posts do próprio usuário
      p.is_public = TRUE 
      OR p.author_id = p_requesting_user_id
    )
    AND (p_tag_filter IS NULL OR pt.tag = LOWER(p_tag_filter))
    AND (p_author_filter IS NULL OR p.author_id = p_author_filter);

  -- 3. BUSCAR POSTS COM PAGINAÇÃO
  SELECT JSON_BUILD_OBJECT(
    'posts', COALESCE(JSON_AGG(post_data), '[]'::JSON),
    'total_count', v_total_count
  )
  INTO v_posts
  FROM (
    SELECT JSON_BUILD_OBJECT(
      'id', p.id,
      'title', p.title,
      'content', LEFT(p.content, 200) || CASE 
        WHEN LENGTH(p.content) > 200 THEN '...' 
        ELSE '' 
      END AS preview,
      'author', JSON_BUILD_OBJECT(
        'id', u.id,
        'name', u.full_name,
        'avatar_url', u.avatar_url
      ),
      'tags', COALESCE(
        ARRAY_AGG(DISTINCT pt.tag) FILTER (WHERE pt.tag IS NOT NULL),
        '{}'::TEXT[]
      ),
      'is_public', p.is_public,
      'view_count', p.view_count,
      'created_at', p.created_at,
      'updated_at', p.updated_at,
      'can_edit', (p.author_id = p_requesting_user_id)
    ) AS post_data
    FROM posts p
    INNER JOIN users u ON u.id = p.author_id
    LEFT JOIN post_tags pt ON pt.post_id = p.id
    WHERE 
      p.deleted_at IS NULL
      AND (
        p.is_public = TRUE 
        OR p.author_id = p_requesting_user_id
      )
      AND (p_tag_filter IS NULL OR p.id IN (
        SELECT post_id FROM post_tags WHERE tag = LOWER(p_tag_filter)
      ))
      AND (p_author_filter IS NULL OR p.author_id = p_author_filter)
    GROUP BY p.id, u.id, u.full_name, u.avatar_url
    ORDER BY p.created_at DESC
    LIMIT p_limit
    OFFSET v_offset
  ) AS posts_subquery;

  -- 4. RETORNAR RESULTADO
  RETURN v_posts;

EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error in get_posts_paginated: %', SQLERRM;
    RAISE EXCEPTION '%', SQLERRM;
END;
$$;

COMMENT ON FUNCTION get_posts_paginated IS 
'Retorna posts paginados com filtros opcionais de tag e autor';

GRANT EXECUTE ON FUNCTION get_posts_paginated TO authenticated;
GRANT EXECUTE ON FUNCTION get_posts_paginated TO anon;
```

#### 3. Função RPC: `update_post`

```sql
CREATE OR REPLACE FUNCTION update_post(
  p_post_id UUID,
  p_user_id UUID,
  p_title TEXT DEFAULT NULL,
  p_content TEXT DEFAULT NULL,
  p_tags TEXT[] DEFAULT NULL,
  p_is_public BOOLEAN DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  content TEXT,
  tags TEXT[],
  is_public BOOLEAN,
  updated_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY INVOKER
VOLATILE
SET search_path = public
AS $$
DECLARE
  v_author_id UUID;
BEGIN
  -- 1. VALIDAÇÕES
  IF p_post_id IS NULL THEN
    RAISE EXCEPTION 'post_id is required';
  END IF;

  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'user_id is required';
  END IF;

  -- 2. VERIFICAR OWNERSHIP
  SELECT author_id INTO v_author_id
  FROM posts
  WHERE id = p_post_id AND deleted_at IS NULL;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Post not found';
  END IF;

  IF v_author_id != p_user_id THEN
    -- Verificar se é admin
    IF NOT EXISTS (
      SELECT 1 FROM users 
      WHERE id = p_user_id 
      AND role = 'admin'
    ) THEN
      RAISE EXCEPTION 'You do not have permission to edit this post';
    END IF;
  END IF;

  -- 3. ATUALIZAR POST
  UPDATE posts
  SET
    title = COALESCE(NULLIF(TRIM(p_title), ''), title),
    content = COALESCE(NULLIF(TRIM(p_content), ''), content),
    is_public = COALESCE(p_is_public, is_public),
    updated_at = NOW()
  WHERE id = p_post_id;

  -- 4. ATUALIZAR TAGS (se fornecidas)
  IF p_tags IS NOT NULL THEN
    -- Remover tags antigas
    DELETE FROM post_tags WHERE post_id = p_post_id;
    
    -- Adicionar novas tags
    IF array_length(p_tags, 1) > 0 THEN
      INSERT INTO post_tags (post_id, tag)
      SELECT p_post_id, LOWER(TRIM(unnest))
      FROM unnest(p_tags)
      WHERE LENGTH(TRIM(unnest)) > 0
      ON CONFLICT (post_id, tag) DO NOTHING;
    END IF;
  END IF;

  -- 5. RETORNAR POST ATUALIZADO
  RETURN QUERY
  SELECT 
    p.id,
    p.title,
    p.content,
    COALESCE(
      ARRAY_AGG(pt.tag) FILTER (WHERE pt.tag IS NOT NULL),
      '{}'::TEXT[]
    ) AS tags,
    p.is_public,
    p.updated_at
  FROM posts p
  LEFT JOIN post_tags pt ON pt.post_id = p.id
  WHERE p.id = p_post_id
  GROUP BY p.id;

EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error in update_post for post % by user %: %', 
      p_post_id, p_user_id, SQLERRM;
    RAISE EXCEPTION '%', SQLERRM;
END;
$$;

COMMENT ON FUNCTION update_post IS 
'Atualiza um post existente com verificação de ownership';

GRANT EXECUTE ON FUNCTION update_post TO authenticated;
```

---

## Design de Tabelas

### Schema Completo para o Sistema de Posts

```sql
-- Extensões necessárias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tabela de usuários
CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  full_name TEXT NOT NULL,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin', 'moderator')),
  email_verified BOOLEAN NOT NULL DEFAULT FALSE,
  metadata JSONB DEFAULT '{}'::JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Índices para users
CREATE INDEX idx_users_email ON public.users(email) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON public.users(role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_created_at ON public.users(created_at DESC);

-- Tabela de posts
CREATE TABLE IF NOT EXISTS public.posts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  author_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  title TEXT NOT NULL CHECK (LENGTH(TRIM(title)) >= 3 AND LENGTH(title) <= 200),
  content TEXT NOT NULL CHECK (LENGTH(TRIM(content)) >= 10),
  is_public BOOLEAN NOT NULL DEFAULT TRUE,
  view_count INTEGER NOT NULL DEFAULT 0 CHECK (view_count >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Índices para posts
CREATE INDEX idx_posts_author_id ON public.posts(author_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_posts_is_public ON public.posts(is_public) WHERE deleted_at IS NULL;
CREATE INDEX idx_posts_created_at ON public.posts(created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_posts_author_created ON public.posts(author_id, created_at DESC) 
  WHERE deleted_at IS NULL;

-- Tabela de tags dos posts
CREATE TABLE IF NOT EXISTS public.post_tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
  tag TEXT NOT NULL CHECK (LENGTH(TRIM(tag)) > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(post_id, tag)
);

-- Índices para post_tags
CREATE INDEX idx_post_tags_post_id ON public.post_tags(post_id);
CREATE INDEX idx_post_tags_tag ON public.post_tags(tag);

-- Tabela de estatísticas de usuário
CREATE TABLE IF NOT EXISTS public.user_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
  total_posts INTEGER NOT NULL DEFAULT 0 CHECK (total_posts >= 0),
  total_views INTEGER NOT NULL DEFAULT 0 CHECK (total_views >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Índice para user_stats
CREATE INDEX idx_user_stats_user_id ON public.user_stats(user_id);

-- Trigger para updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at_users
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_updated_at_posts
  BEFORE UPDATE ON public.posts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_updated_at_user_stats
  BEFORE UPDATE ON public.user_stats
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Comentários de documentação
COMMENT ON TABLE public.users IS 'Tabela principal de usuários do sistema';
COMMENT ON TABLE public.posts IS 'Tabela de posts criados pelos usuários';
COMMENT ON TABLE public.post_tags IS 'Tags associadas aos posts';
COMMENT ON TABLE public.user_stats IS 'Estatísticas agregadas por usuário';

COMMENT ON COLUMN public.posts.view_count IS 'Contador de visualizações do post';
COMMENT ON COLUMN public.posts.is_public IS 'Define se o post é visível publicamente';
COMMENT ON COLUMN public.users.metadata IS 'Dados adicionais flexíveis em formato JSON';
```

---

## Row Level Security (RLS)

### Políticas RLS para o Sistema de Posts

```sql
-- ============================================================================
-- RLS PARA TABELA USERS
-- ============================================================================

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- SELECT: Usuários podem ver perfis públicos e seu próprio perfil
CREATE POLICY "Users can view public profiles and their own"
  ON public.users
  FOR SELECT
  TO authenticated
  USING (
    deleted_at IS NULL
    AND (
      id = auth.uid()  -- Próprio perfil
      OR email_verified = TRUE  -- Perfis verificados são públicos
    )
  );

-- SELECT anônimo: Apenas perfis públicos verificados
CREATE POLICY "Anonymous can view verified profiles"
  ON public.users
  FOR SELECT
  TO anon
  USING (
    deleted_at IS NULL 
    AND email_verified = TRUE
  );

-- UPDATE: Usuários podem atualizar apenas seu próprio perfil
CREATE POLICY "Users can update their own profile"
  ON public.users
  FOR UPDATE
  TO authenticated
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- Service role bypassa RLS
CREATE POLICY "Service role has full access to users"
  ON public.users
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================================================
-- RLS PARA TABELA POSTS
-- ============================================================================

ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- SELECT: Ver posts públicos ou próprios posts
CREATE POLICY "Users can view public posts or their own"
  ON public.posts
  FOR SELECT
  TO authenticated
  USING (
    deleted_at IS NULL
    AND (
      is_public = TRUE
      OR author_id = auth.uid()
    )
  );

-- SELECT anônimo: Apenas posts públicos
CREATE POLICY "Anonymous can view public posts"
  ON public.posts
  FOR SELECT
  TO anon
  USING (
    deleted_at IS NULL 
    AND is_public = TRUE
  );

-- INSERT: Apenas via RPC (controlado pela Edge Function)
-- Não criamos política de INSERT direto para forçar uso da função RPC
-- que tem todas as validações

-- UPDATE: Apenas próprio autor ou admins
CREATE POLICY "Users can update their own posts"
  ON public.posts
  FOR UPDATE
  TO authenticated
  USING (
    deleted_at IS NULL
    AND (
      author_id = auth.uid()
      OR EXISTS (
        SELECT 1 FROM public.users
        WHERE id = auth.uid()
        AND role = 'admin'
      )
    )
  )
  WITH CHECK (
    author_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.users
      WHERE id = auth.uid()
      AND role = 'admin'
    )
  );

-- DELETE (soft): Apenas próprio autor ou admins
CREATE POLICY "Users can delete their own posts"
  ON public.posts
  FOR UPDATE
  TO authenticated
  USING (
    deleted_at IS NULL
    AND (
      author_id = auth.uid()
      OR EXISTS (
        SELECT 1 FROM public.users
        WHERE id = auth.uid()
        AND role IN ('admin', 'moderator')
      )
    )
  );

-- Service role bypassa RLS
CREATE POLICY "Service role has full access to posts"
  ON public.posts
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================================================
-- RLS PARA TABELA POST_TAGS
-- ============================================================================

ALTER TABLE public.post_tags ENABLE ROW LEVEL SECURITY;

-- SELECT: Ver tags de posts que o usuário pode ver
CREATE POLICY "Users can view tags of accessible posts"
  ON public.post_tags
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.posts
      WHERE posts.id = post_tags.post_id
      AND posts.deleted_at IS NULL
      AND (
        posts.is_public = TRUE
        OR posts.author_id = auth.uid()
      )
    )
  );

-- SELECT anônimo: Tags de posts públicos
CREATE POLICY "Anonymous can view tags of public posts"
  ON public.post_tags
  FOR SELECT
  TO anon
  USING (
    EXISTS (
      SELECT 1 FROM public.posts
      WHERE posts.id = post_tags.post_id
      AND posts.deleted_at IS NULL
      AND posts.is_public = TRUE
    )
  );

-- INSERT/UPDATE/DELETE: Apenas via RPC
-- (controlado pelas funções RPC que gerenciam tags)

-- Service role bypassa RLS
CREATE POLICY "Service role has full access to post_tags"
  ON public.post_tags
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================================================
-- RLS PARA TABELA USER_STATS
-- ============================================================================

ALTER TABLE public.user_stats ENABLE ROW LEVEL SECURITY;

-- SELECT: Usuários podem ver estatísticas de perfis públicos
CREATE POLICY "Users can view public user stats"
  ON public.user_stats
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE users.id = user_stats.user_id
      AND users.deleted_at IS NULL
      AND (
        users.id = auth.uid()
        OR users.email_verified = TRUE
      )
    )
  );

-- SELECT anônimo: Stats de usuários verificados
CREATE POLICY "Anonymous can view stats of verified users"
  ON public.user_stats
  FOR SELECT
  TO anon
  USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE users.id = user_stats.user_id
      AND users.deleted_at IS NULL
      AND users.email_verified = TRUE
    )
  );

-- UPDATE: Apenas via RPC/Triggers
-- (estatísticas são atualizadas automaticamente)

-- Service role bypassa RLS
CREATE POLICY "Service role has full access to user_stats"
  ON public.user_stats
  TO service_role
  USING (true)
  WITH CHECK (true);
```

---

## Estrutura de Diretórios

```
/supabase
├── /functions              # Edge Functions (APIs)
│   ├── /create-post
│   │   └── index.ts
│   ├── /get-posts
│   │   └── index.ts
│   ├── /update-post
│   │   └── index.ts
│   ├── /delete-post
│   │   └── index.ts
│   └── /_shared           # Código compartilhado
│       ├── auth.ts        # Helpers de autenticação
│       ├── validation.ts  # Schemas de validação
│       └── types.ts       # Tipos TypeScript
│
├── /migrations            # Migrations SQL
│   ├── 001_initial_schema.sql
│   ├── 002_rpc_functions.sql
│   └── 003_rls_policies.sql
│
└── /seed                  # Dados de teste
    └── seed.sql
```

---

## Checklist de Implementação

### Para Cada Nova Funcionalidade

#### 1. Planejamento
- [ ] Definir endpoint da Edge Function
- [ ] Identificar operações no banco de dados
- [ ] Mapear funções RPC necessárias
- [ ] Listar tabelas envolvidas

#### 2. Banco de Dados
- [ ] Criar/modificar tabelas com constraints
- [ ] Adicionar índices apropriados
- [ ] Criar triggers necessários
- [ ] Criar funções RPC com toda lógica de negócio
- [ ] Adicionar comentários de documentação
- [ ] Testar funções RPC isoladamente

#### 3. RLS
- [ ] Ativar RLS nas tabelas
- [ ] Criar política para SELECT
- [ ] Criar política para INSERT (se aplicável)
- [ ] Criar política para UPDATE (se aplicável)
- [ ] Criar política para DELETE (se aplicável)
- [ ] Criar política para service_role
- [ ] Testar políticas com diferentes usuários

#### 4. Edge Function
- [ ] Criar estrutura básica com CORS
- [ ] Implementar autenticação JWT
- [ ] Adicionar validação de input
- [ ] Implementar chamada(s) RPC
- [ ] Transformar resposta para o cliente
- [ ] Adicionar tratamento de erros
- [ ] Adicionar logging
- [ ] Testar localmente

#### 5. Testes
- [ ] Testar Edge Function com Postman/curl
- [ ] Testar diferentes cenários de erro
- [ ] Testar permissões RLS
- [ ] Testar rate limiting (se aplicável)
- [ ] Testar performance com dados reais

#### 6. Documentação
- [ ] Documentar endpoint da API
- [ ] Documentar parâmetros e respostas
- [ ] Documentar códigos de erro
- [ ] Adicionar exemplos de uso

---

## Padrões de Nomenclatura

### Edge Functions
- Usar kebab-case: `create-post`, `get-user-profile`
- Verbos no início: `create-`, `get-`, `update-`, `delete-`
- Nomes descritivos do recurso

### Funções RPC
- Usar snake_case: `create_post`, `get_posts_paginated`
- Prefixar parâmetros com `p_`: `p_user_id`, `p_title`
- Prefixar variáveis locais com `v_`: `v_post_id`, `v_result`

### Tabelas
- Usar plural snake_case: `users`, `posts`, `post_tags`
- Nomes claros e descritivos

### Colunas
- Usar snake_case: `user_id`, `created_at`, `is_public`
- Sempre incluir: `id`, `created_at`, `updated_at`
- Considerar: `deleted_at` para soft deletes

---

## Melhores Práticas de Segurança

### Camada de Edge Function
1. **Sempre validar JWT** antes de qualquer operação
2. **Sanitizar inputs** antes de passar para RPC
3. **Usar variáveis de ambiente** para secrets
4. **Implementar rate limiting** quando apropriado
5. **Logar operações sensíveis** sem expor dados privados
6. **Retornar erros genéricos** ao cliente (detalhes apenas em logs)

### Camada RPC
1. **SECURITY INVOKER** sempre que possível
2. **Validar permissões** dentro da função quando necessário
3. **SET search_path** explicitamente
4. **Usar prepared statements** (parameterized queries)
5. **RAISE EXCEPTION** para erros de negócio

### Camada RLS
1. **Enable RLS** em todas as tabelas
2. **Deny by default** - sem políticas, sem acesso
3. **Políticas granulares** por operação (SELECT, INSERT, UPDATE, DELETE)
4. **Testar com diferentes roles** (authenticated, anon, service_role)
5. **Usar índices** em colunas usadas nas políticas

---

**Lembre-se**: Edge Functions são seu gateway de API, RPC é sua lógica de negócio, e RLS é sua última linha de defesa. Use as três camadas adequadamente para máxima segurança e flexibilidade!